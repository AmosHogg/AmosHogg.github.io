(window.webpackJsonp=window.webpackJsonp||[]).push([[164],{480:function(t,a,s){"use strict";s.r(a);var _=s(3),v=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-什么是所有权"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是所有权"}},[t._v("#")]),t._v(" 1. 什么是所有权")]),t._v(" "),a("p",[t._v("Rust 的核心特性就是所有权: 所有程序在运行时都必须管理它们使用计算机内存的方式。有些语言有垃圾收集机制，在程序运行时，它们会不断地寻找不再使用的内存。（在其他语言中，程序员必须显式地分配和释放内存）")]),t._v(" "),a("p",[t._v("Rust 采用了第三种方式：")]),t._v(" "),a("ul",[a("li",[t._v("内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则。")]),t._v(" "),a("li",[t._v("当程序运行时，所有权特性不会减慢程序的运行速度。")])]),t._v(" "),a("h2",{attrs:{id:"_2-stack-vs-heap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-stack-vs-heap"}},[t._v("#")]),t._v(" 2. Stack vs Heap")]),t._v(" "),a("h3",{attrs:{id:"_2-1-栈内存和堆内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-栈内存和堆内存"}},[t._v("#")]),t._v(" 2.1 栈内存和堆内存")]),t._v(" "),a("p",[t._v("在像 Rus†这样的系统级编程语言里，一个值是在 stack 上还是在 heap 上对语言的行为和你为什么要做某些决定是有更大的影响的")]),t._v(" "),a("p",[t._v("在你的代码运行的时候，Stack 和 Heap 都是你可用的内存，但他们的结构很不相同。")]),t._v(" "),a("h3",{attrs:{id:"_2-2-储存数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-储存数据"}},[t._v("#")]),t._v(" 2.2 储存数据")]),t._v(" "),a("ul",[a("li",[t._v("Stack 按值的接收顺序来存储，按相反的顺序将它们移除（后进先出，LIFO）\n"),a("ul",[a("li",[t._v("添加数据叫做压入栈")]),t._v(" "),a("li",[t._v("移除数据叫做弹出栈")])])]),t._v(" "),a("li",[t._v("所有存储在 Stack 上的数据必须拥有己知的固定的大小\n"),a("ul",[a("li",[t._v("编译时大小未知的数据或运行时大小可能发生变化的数据必须存放在 heap 上")])])]),t._v(" "),a("li",[t._v("Heap 内存组织性差一些：\n"),a("ul",[a("li",[t._v("当你把数据放入 heap 时，你会请求一定数量的空间")]),t._v(" "),a("li",[t._v("操作系统在 heap 里找到一块足够大的空间，把它标记为在用，并返回一个指针，也就是这个空间的地址")]),t._v(" "),a("li",[t._v("这个过程叫做在 heap 上进行分配，有时仅仅称为“分配”")])])]),t._v(" "),a("li",[t._v("把值压到 stack 上不叫分配")]),t._v(" "),a("li",[t._v("因为指针是己知固定大小的，可以把指针存放在 stack 上。\n"),a("ul",[a("li",[t._v("但如果想要实际数据，你必须使用指针来定位。")])])]),t._v(" "),a("li",[t._v("把数据压到 stack 上要比在 heap 上分配快得多：\n"),a("ul",[a("li",[t._v("因为操作系统不需要寻找用来存储新数据的空间，那个位置永远都在 stack 的顶端")])])]),t._v(" "),a("li",[t._v("在heap 上分配空间需要做更多的工作：\n"),a("ul",[a("li",[t._v("操作系统首先需要找到一个足够大的空间来存放数据，然后要做好记录方便下次分配")])])]),t._v(" "),a("li",[t._v("访问 heap 中的数据要比访问 stack 中的数据慢，因为需要通过指针才能找到 heap 中的数据\n"),a("ul",[a("li",[t._v("对于现代的处理器来说，由于缓存的缘故，如果指令在内存中跳转的次数越少，那么速度就越快")])])])]),t._v(" "),a("h3",{attrs:{id:"_2-3-访问数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-访问数据"}},[t._v("#")]),t._v(" 2.3 访问数据")]),t._v(" "),a("ul",[a("li",[t._v("访问 heap 中的数据要比访问 stack 中的数据慢，因为需要通过指针才能找到 heap 中的数据\n"),a("ul",[a("li",[t._v("对于现代的处理器来说，由于缓存的缘故，如果指令在内存中跳转的次数越少，那么速度就越快")])])]),t._v(" "),a("li",[t._v("如果数据存放的距离比较近，那么处理器的处理速度就会更快一些 （stack 上）")]),t._v(" "),a("li",[t._v("如果数据之间的距离比较远，那么处理速度就会慢一些（heap 上）")])]),t._v(" "),a("h3",{attrs:{id:"_2-4-函数调用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-函数调用"}},[t._v("#")]),t._v(" 2.4 函数调用")]),t._v(" "),a("p",[t._v("当你的代码调用函数时，值被传入到函数（也包括指向 heap 的指针）。函数本地的变量被压到 stack 上。当函数结束后，这些值会从 stack 上弹出")]),t._v(" "),a("h2",{attrs:{id:"_3-所有权存在的原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-所有权存在的原因"}},[t._v("#")]),t._v(" 3. 所有权存在的原因")]),t._v(" "),a("p",[t._v("所有权解决的问题：")]),t._v(" "),a("ul",[a("li",[t._v("跟踪代码的哪些部分正在使用 heap 的哪些数据")]),t._v(" "),a("li",[t._v("最小化 heap 上的重复数据量")]),t._v(" "),a("li",[t._v("清理 heap 上未使用的数据以避免空间不足")])]),t._v(" "),a("p",[t._v("一旦你懂的了所有权，那么就不需要经常去想 stack 或 heap了。但是知道管理 heap 数据是所有权存在的原因，这有助于解释它为什么会这样工作。")]),t._v(" "),a("h2",{attrs:{id:"_4-所有权规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-所有权规则"}},[t._v("#")]),t._v(" 4. 所有权规则")]),t._v(" "),a("p",[t._v("每个值都有一个变量，这个变量是该值的所有者。每个值同时只能有一个所有者。当所有者超出作用域（scope）时，该值将被删除。")]),t._v(" "),a("h3",{attrs:{id:"_4-1-变量的作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-变量的作用域"}},[t._v("#")]),t._v(" 4.1 变量的作用域")]),t._v(" "),a("p",[t._v("Scope 就是程序中一个项目的有效范围。")]),t._v(" "),a("div",{staticClass:"language-Rust line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-definition function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("println!")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("\"i is '{}'.\"")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 0")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("println!")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("\"i is '{}'.\"")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// arr")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("h3",{attrs:{id:"_4-2-string-类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-string-类型"}},[t._v("#")]),t._v(" 4.2 String 类型")]),t._v(" "),a("p",[t._v("String 比那些基础标量数据类型更复杂（储存在堆上的数据类型）。")]),t._v(" "),a("p",[t._v("在heap 上分配。能够存储在编译时未知数量的文本。")]),t._v(" "),a("h4",{attrs:{id:"创建-string-类型的值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建-string-类型的值"}},[t._v("#")]),t._v(" 创建 String 类型的值")]),t._v(" "),a("p",[t._v("可以使用 from 函数从字符串字面值创建出 String 类型。 eg. "),a("code",[t._v('let s = String::from("hello");')])]),t._v(" "),a("h2",{attrs:{id:"_5-内存和分配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-内存和分配"}},[t._v("#")]),t._v(" 5. 内存和分配")]),t._v(" "),a("p",[t._v("字符串字面值，在编译时就知道它的内容了，其文本内容直接被硬编码到最终的可执行文件里（速度快、高效。是因为其不可变性）。")]),t._v(" "),a("p",[t._v("String 类型，为了支持可变性，需要在 heap 上分配内存来保存编译时未知的文本内容：")]),t._v(" "),a("ul",[a("li",[t._v("操作系统必须在运行时来请求内存\n"),a("ul",[a("li",[t._v("这步通过调用 String::from 来实现")])])]),t._v(" "),a("li",[t._v("当用完 String 之后，需要使用某种方式将内存返回给操作系统\n"),a("ul",[a("li",[t._v("这步，在拥有 GC 的语言中，GC 会跟踪并清理不再使用的内存")]),t._v(" "),a("li",[t._v("没有GC，就需要我们去识别内存何时不再使用，并调用代码将它返回。\n"),a("ul",[a("li",[t._v("如果忘了，那就浪费内存")]),t._v(" "),a("li",[t._v("如果提前做了，变量就会非法")]),t._v(" "),a("li",[t._v("如果做了两次，也是 Bug。必须一次分配对应一次释放")])])])])])]),t._v(" "),a("p",[t._v("Rust 采用了不同的方式：对于某个值来说，当拥有它的变量走出作用范围时，内存会立即自动的交还给操作系统。")]),t._v(" "),a("h2",{attrs:{id:"_6-所有权和函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-所有权和函数"}},[t._v("#")]),t._v(" 6. 所有权和函数")]),t._v(" "),a("p",[t._v("在语义上，将值传递给函数和把值赋给变量是类似的：将值传递给函数将发生移动或复制。")])])}),[],!1,null,null,null);a.default=v.exports}}]);