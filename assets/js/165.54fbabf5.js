(window.webpackJsonp=window.webpackJsonp||[]).push([[165],{486:function(t,_,a){"use strict";a.r(_);var v=a(3),s=Object(v.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"_1-引用和借用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-引用和借用"}},[t._v("#")]),t._v(" 1. 引用和借用")]),t._v(" "),_("p",[t._v("参数的类型是 &type 而不是 type。")]),t._v(" "),_("p",[t._v("＆符号就表示引用：允许你引用某些值而不取得其所有权。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://jihulab.com/AmosHogg/picbed/-/raw/main/pictures/2023/05/2_13_34_0_202305021334023.png",alt:"借用和引用"}})]),t._v(" "),_("h2",{attrs:{id:"_2-可变引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-可变引用"}},[t._v("#")]),t._v(" 2. 可变引用")]),t._v(" "),_("p",[t._v("可变引用有一个重要的限制：在特定作用域内，对某一块数据，只能有一个可变的引用。这样做的好处是可在编译时防止数据竞争。")]),t._v(" "),_("p",[t._v("以下三种行为下会发生数据竞争：")]),t._v(" "),_("ul",[_("li",[t._v("两个或多个指针同时访问同一个数据")]),t._v(" "),_("li",[t._v("至少有一个指针用于写入数据")]),t._v(" "),_("li",[t._v("没有使用任何机制来同步对数据的访问")])]),t._v(" "),_("p",[t._v("可以通过创建新的作用域，来允许非同时的创建多个可变引用。")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("另外一个限制")]),t._v("\n不可以同时拥有一个可变引用和一个不变的引用。")])]),t._v(" "),_("h2",{attrs:{id:"悬空引用-dangling-references"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#悬空引用-dangling-references"}},[t._v("#")]),t._v(" 悬空引用 Dangling References")]),t._v(" "),_("p",[t._v("悬空指针(Dangling Pointer)：一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其它人使用了。")]),t._v(" "),_("p",[t._v("在 Rust 里，编译器可保证引用永远都不是悬空引用：")]),t._v(" "),_("ul",[_("li",[t._v("如果你引用了某些数据，编译器将保证在引用离开作用城之前数据不会离开作用城")])]),t._v(" "),_("h2",{attrs:{id:"_3-引用的规则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-引用的规则"}},[t._v("#")]),t._v(" 3. 引用的规则")]),t._v(" "),_("p",[t._v("在任何给定的时刻，只能满足下列条件之一：")]),t._v(" "),_("ul",[_("li",[t._v("一个可变的引用")]),t._v(" "),_("li",[t._v("任意数量不可变的引用")])])])}),[],!1,null,null,null);_.default=s.exports}}]);